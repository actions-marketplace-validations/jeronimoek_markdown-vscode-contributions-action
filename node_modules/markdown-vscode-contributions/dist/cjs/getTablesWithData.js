"use strict";

require("core-js/modules/es.symbol.description.js");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTablesWithData = getTablesWithData;
require("core-js/modules/es.array.flat-map.js");
require("core-js/modules/es.array.unscopables.flat-map.js");
require("core-js/modules/es.array.flat.js");
require("core-js/modules/es.array.unscopables.flat.js");
require("core-js/modules/es.regexp.exec.js");
require("core-js/modules/es.string.replace.js");
require("core-js/modules/es.string.replace-all.js");
require("core-js/modules/es.array.iterator.js");
require("core-js/modules/es.string.match-all.js");
require("core-js/modules/es.array.push.js");
require("core-js/modules/es.error.cause.js");
require("core-js/modules/es.json.stringify.js");
var _enums = require("./enums");
var _stringWidth = _interopRequireDefault(require("string-width"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function flattenObject(obj) {
  const flattened = {};
  Object.keys(obj).forEach(key => {
    const value = obj[key];
    if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      Object.assign(flattened, flattenObject(value));
    } else {
      flattened[key] = value;
    }
  });
  return flattened;
}
function propsNestedObject(contributionArr) {
  return contributionArr.map(contribution => flattenObject(contribution));
}
function propsPlain(contributionArr) {
  return contributionArr;
}
function propsWithAreas(contributions) {
  return Object.keys(contributions).flatMap(area => {
    return contributions[area].map(contribution => _objectSpread(_objectSpread({}, contribution), {}, {
      area
    }));
  });
}
function propsConfiguration(settings) {
  return Object.keys(settings.properties).map(property => {
    return _objectSpread(_objectSpread({}, settings.properties[property]), {}, {
      property,
      title: settings.title,
      order: settings.order
    });
  });
}
function propsDebuggers(debuggers) {
  return debuggers.map(currentDebugger => {
    var _currentDebugger$stri, _currentDebugger$linu, _currentDebugger$osx, _currentDebugger$wind;
    return _objectSpread(_objectSpread({}, currentDebugger), {}, {
      unverifiedBreakpoints: (_currentDebugger$stri = currentDebugger.strings) === null || _currentDebugger$stri === void 0 ? void 0 : _currentDebugger$stri.unverifiedBreakpoints,
      linuxRuntime: (_currentDebugger$linu = currentDebugger.linux) === null || _currentDebugger$linu === void 0 ? void 0 : _currentDebugger$linu.runtime,
      osxRuntime: (_currentDebugger$osx = currentDebugger.osx) === null || _currentDebugger$osx === void 0 ? void 0 : _currentDebugger$osx.runtime,
      windowsRuntime: (_currentDebugger$wind = currentDebugger.windows) === null || _currentDebugger$wind === void 0 ? void 0 : _currentDebugger$wind.runtime
    });
  });
}
function propsDocumentation(documentation) {
  return documentation.refactoring;
}
function propsIcons(icons) {
  return Object.keys(icons).map(iconId => {
    return _objectSpread(_objectSpread({}, flattenObject(icons[iconId])), {}, {
      iconId
    });
  });
}
function propsFlatObjectOrObjectArray(contributionArr) {
  return [contributionArr].flat();
}

// TODO: missing "quickFixes" data
function propsTerminalProfiles(terminal) {
  return terminal.profiles.map(profile => flattenObject(profile));
}
function propsSemanticTokenScopes(semanticTokenScopes) {
  return semanticTokenScopes.map(semanticTokenScope => {
    const {
      language,
      scopes
    } = semanticTokenScope;
    return Object.keys(scopes).map(scope => {
      return scopes[scope].map(fallbackScope => ({
        language,
        scope,
        fallbackScope
      }));
    });
  }).flat(3);
}
function propsProblemMatchers(problemMatchers) {
  return problemMatchers.map(problemMatcher => {
    var _problemMatcher$backg, _problemMatcher$backg2, _problemMatcher$backg3, _problemMatcher$backg4, _problemMatcher$backg5, _problemMatcher$backg6, _problemMatcher$backg7, _problemMatcher$backg8, _problemMatcher$backg9;
    return _objectSpread(_objectSpread({}, problemMatcher), {}, {
      activeOnStart: (_problemMatcher$backg = problemMatcher.background) === null || _problemMatcher$backg === void 0 ? void 0 : _problemMatcher$backg.activeOnStart,
      beginsPatternFile: (_problemMatcher$backg2 = problemMatcher.background) === null || _problemMatcher$backg2 === void 0 ? void 0 : (_problemMatcher$backg3 = _problemMatcher$backg2.beginsPattern) === null || _problemMatcher$backg3 === void 0 ? void 0 : _problemMatcher$backg3.file,
      beginsPatternRegexp: (_problemMatcher$backg4 = problemMatcher.background) === null || _problemMatcher$backg4 === void 0 ? void 0 : (_problemMatcher$backg5 = _problemMatcher$backg4.beginsPattern) === null || _problemMatcher$backg5 === void 0 ? void 0 : _problemMatcher$backg5.regexp,
      endsPatternFile: (_problemMatcher$backg6 = problemMatcher.background) === null || _problemMatcher$backg6 === void 0 ? void 0 : (_problemMatcher$backg7 = _problemMatcher$backg6.endsPattern) === null || _problemMatcher$backg7 === void 0 ? void 0 : _problemMatcher$backg7.file,
      endsPatternRegexp: (_problemMatcher$backg8 = problemMatcher.background) === null || _problemMatcher$backg8 === void 0 ? void 0 : (_problemMatcher$backg9 = _problemMatcher$backg8.endsPattern) === null || _problemMatcher$backg9 === void 0 ? void 0 : _problemMatcher$backg9.regexp
    }, problemMatcher.pattern);
  });
}
function propsArray(contributions) {
  return contributions.map(contribution => ({
    data: contribution
  }));
}
function propsConfigurationDefaults(configurationDefaults) {
  return Object.keys(configurationDefaults).map(key => {
    if (key.startsWith("[") && key.endsWith("]")) {
      const languageConfigurationDefaults = configurationDefaults[key];
      return Object.keys(languageConfigurationDefaults).map(configurationDefault => ({
        language: key,
        configurationDefault,
        configurationDefaultValue: languageConfigurationDefaults[configurationDefault]
      }));
    } else {
      return {
        configurationDefault: key,
        configurationDefaultValue: configurationDefaults[key]
      };
    }
  });
}
function propsFunctionByContribution(tableName) {
  switch (tableName) {
    case _enums.Contributions.CONFIGURATION:
      return propsConfiguration;
    case _enums.Contributions.DEBUGGERS:
      return propsDebuggers;
    case _enums.Contributions.DOCUMENTATION:
      return propsDocumentation;
    case _enums.Contributions.ICONS:
      return propsIcons;
    case _enums.Contributions.TERMINALPROFILES:
      return propsTerminalProfiles;
    case _enums.Contributions.SEMANTICTOKENSCOPES:
      return propsSemanticTokenScopes;
    case _enums.Contributions.PROBLEMMATCHERS:
      return propsProblemMatchers;
    case _enums.Contributions.CONFIGURATIONDEFAULTS:
      return propsConfigurationDefaults;
    case _enums.Contributions.CSSCUSTOMDATA:
    case _enums.Contributions.HTMLCUSTOMDATA:
    case _enums.Contributions.MARKDOWNPREVIEWSCRIPTS:
    case _enums.Contributions.MARKDOWNPREVIEWSTYLES:
      return propsArray;
    case _enums.Contributions.MENUS:
    case _enums.Contributions.VIEWS:
    case _enums.Contributions.VIEWSCONTAINERS:
      return propsWithAreas;
    case _enums.Contributions.COMMANDS:
    case _enums.Contributions.KEYBINDINGS:
      return propsFlatObjectOrObjectArray;
    case _enums.Contributions.CODEACTIONS:
    case _enums.Contributions.COLORS:
    case _enums.Contributions.LANGUAGES:
    case _enums.Contributions.RESOURCELABELFORMATTERS:
    case _enums.Contributions.SUBMENUS:
      return propsNestedObject;
    case _enums.Contributions.AUTHENTICATION:
    case _enums.Contributions.BREAKPOINTS:
    case _enums.Contributions.CONTINUEEDITSESSION:
    case _enums.Contributions.CUSTOMEDITORS:
    case _enums.Contributions.GRAMMARS:
    case _enums.Contributions.HTMLLANGUAGEPARTICIPANTS:
    case _enums.Contributions.ICONTHEMES:
    case _enums.Contributions.JSONVALIDATION:
    case _enums.Contributions.LOCALIZATIONS:
    case _enums.Contributions.NOTEBOOKPRELOAD:
    case _enums.Contributions.NOTEBOOKRENDERER:
    case _enums.Contributions.NOTEBOOKS:
    case _enums.Contributions.PROBLEMPATTERNS:
    case _enums.Contributions.PRODUCTICONTHEMES:
    case _enums.Contributions.SEMANTICTOKENMODIFIERS:
    case _enums.Contributions.SEMANTICTOKENTYPES:
    case _enums.Contributions.SNIPPETS:
    case _enums.Contributions.TASKDEFINITIONS: // TODO: could improve "properties" and "required" data
    case _enums.Contributions.THEMES:
    case _enums.Contributions.TYPESCRIPTSERVERPLUGINS:
    case _enums.Contributions.VIEWSWELCOME:
    case _enums.Contributions.WALKTHROUGHS:
    default:
      return propsPlain;
  }
}
function getContributions(packageFile) {
  const contributions = JSON.parse(packageFile).contributes;
  return contributions;
}
function escapeMarkdown(str = "") {
  return str.replaceAll(/([*_])/gi, "\\$1");
}
function getTablesInfo(inputFile) {
  const tablesToInsertMatched = [...inputFile.matchAll(/(?<=\r?\n|^)\[\/\/\]: # [("]vscode-table-(.+)\((.+)\)[)"](?=\r?\n|$)/gi)];
  const tablesToInsert = tablesToInsertMatched.reduce((accTables, currTable) => {
    const [match, contribution, columnsString] = currTable;
    const columns = columnsString.split("|").reduce((accColumns, currColumn) => {
      const [name, alias] = currColumn.split(":");
      const columnHeader = alias || name;
      accColumns[name] = {
        columnHeader,
        values: [],
        // width: stringWidth(columnHeader),
        width: (0, _stringWidth.default)(columnHeader)
      };
      return accColumns;
    }, {});
    accTables.push({
      contribution,
      columns,
      index: currTable.index || 0,
      endIndex: (currTable.index || 0) + match.length
    });
    return accTables;
  }, []);
  return tablesToInsert;
}
function getTablesWithData(packageFile, inputFile) {
  const tables = getTablesInfo(inputFile);
  const contributions = getContributions(packageFile);
  if (!contributions) throw new Error("Missing contributions property in package");
  for (const table of tables) {
    const contribution = contributions[table.contribution];
    if (!contribution) continue;
    const propsFunction = propsFunctionByContribution(table.contribution);
    const contributionProps = propsFunction(contribution);
    for (const contributionEntry of contributionProps) {
      for (const [columnName, columnProps] of Object.entries(table.columns)) {
        let value = contributionEntry[columnName];
        if (typeof value !== "string") value = JSON.stringify(value);
        value = escapeMarkdown(value);
        columnProps.values.push(value);
        if (value && (0, _stringWidth.default)(value) > columnProps.width) {
          columnProps.width = (0, _stringWidth.default)(value);
        }
      }
    }
  }
  return tables;
}